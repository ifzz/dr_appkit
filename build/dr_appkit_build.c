#include <stdio.h>
#include <string.h>
#include <float.h>

#define DR_CODEGEN_IMPLEMENTATION
#include "../../dr_libs/dr_codegen.h"

#define DR_UTIL_IMPLEMENTATION
#include "../../dr_libs/dr_util.h"

#define DR_PATH_IMPLEMENTATION
#include "../../dr_libs/dr_path.h"

#define DR_VFS_IMPLEMENTATION
#include "../../dr_libs/dr_vfs.h"

#define NANOSVG_ALL_COLOR_KEYWORDS
#define NANOSVG_IMPLEMENTATION
#include "nanosvg.h"
#define NANOSVGRAST_IMPLEMENTATION
#include "nanosvgrast.h"

void copy_image_data(unsigned char* dst, const unsigned char* src, int width, int height, unsigned stride)
{
    for (int row = 0; row < height; ++row) {
        for (int col = 0; col < width; ++col) {
            ((unsigned int*)(dst))[row*width + col] = ((const unsigned int*)(src))[row*(stride/4) + col];
        }
    }
}

int main()
{
#if 0
    const unsigned char testing[] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
    };

    char* output = dr_codegen_buffer_to_c_array(testing, sizeof(testing), "g_MyTest");
    printf("%s", output);
#endif

    char exePath[DRVFS_MAX_PATH];
    if (!dr_get_executable_path(exePath, sizeof(exePath))) {
        return -1;
    }

    char exeDirPath[DRVFS_MAX_PATH];
    drpath_copy_base_path(exePath, exeDirPath, sizeof(exeDirPath));
    
    drvfs_context* pVFS = drvfs_create_context();
    drvfs_set_base_write_directory(pVFS, exeDirPath);
    drvfs_add_base_directory(pVFS, exeDirPath);

    drvfs_file* pFile = drvfs_open(pVFS, "../source/ak_autogen.c", DRVFS_WRITE | DRVFS_TRUNCATE, 0);
    if (pFile == NULL) {
        return -2;
    }

    drvfs_write_line(pFile, "// This file was generated by a tool. Do not modify.\n");


    // Reusable buffers of prefined sizes.
    unsigned char pBuffer16x16[16*16*4];
    unsigned char pBuffer24x24[24*24*4];
    unsigned char pBuffer32x32[32*32*4];


    // Cross.
    char* svg = drvfs_open_and_read_text_file(pVFS, "../resources/cross.svg", NULL);
    NSVGimage* pSVGImage = nsvgParse(svg, "px", 96);
    if (pSVGImage == NULL) {
        drvfs_free(svg);
        return NULL;
    }

    int svgWidth  = (int)pSVGImage->width;
    int svgHeight = (int)pSVGImage->height;

    // At this point we have loaded the image and now we need to rasterize it.
    void* pImageData = malloc(svgWidth * svgHeight * 4);
    if (pImageData == NULL) {
        nsvgDelete(pSVGImage);
        return NULL;
    }

    NSVGrasterizer* pSVGRast = nsvgCreateRasterizer();
    if (pSVGRast == NULL) {
        nsvgDelete(pSVGImage);
        return NULL;
    }

    
    // Cross 16x16.
    nsvgRasterize(pSVGRast, pSVGImage, 0, 0, 16.0f / pSVGImage->width, pImageData, (int)svgWidth, (int)svgHeight, (int)svgWidth*4);
    copy_image_data(pBuffer16x16, pImageData, 16, 16, svgWidth*4);

    // Cross 24x24.
    nsvgRasterize(pSVGRast, pSVGImage, 0, 0, 24.0f / pSVGImage->width, pImageData, (int)svgWidth, (int)svgHeight, (int)svgWidth*4);
    copy_image_data(pBuffer24x24, pImageData, 24, 24, svgWidth*4);

    // Cross 32x32.
    nsvgRasterize(pSVGRast, pSVGImage, 0, 0, 32.0f / pSVGImage->width, pImageData, (int)svgWidth, (int)svgHeight, (int)svgWidth*4);
    copy_image_data(pBuffer32x32, pImageData, 32, 32, svgWidth*4);


    nsvgDeleteRasterizer(pSVGRast);
    nsvgDelete(pSVGImage);
    free(pImageData);
    drvfs_free(svg);


    char* g_AKImage_Cross_16x16 = dr_codegen_buffer_to_c_array(pBuffer16x16, sizeof(pBuffer16x16), "g_AKImage_Cross_16x16");
    if (g_AKImage_Cross_16x16 != NULL) {
        drvfs_write_string(pFile, g_AKImage_Cross_16x16);
        drvfs_write_string(pFile, "\n\n");
        free(g_AKImage_Cross_16x16);
    }

    char* g_AKImage_Cross_24x24 = dr_codegen_buffer_to_c_array(pBuffer24x24, sizeof(pBuffer24x24), "g_AKImage_Cross_24x24");
    if (g_AKImage_Cross_24x24 != NULL) {
        drvfs_write_string(pFile, g_AKImage_Cross_24x24);
        drvfs_write_string(pFile, "\n\n");
        free(g_AKImage_Cross_24x24);
    }

    char* g_AKImage_Cross_32x32 = dr_codegen_buffer_to_c_array(pBuffer32x32, sizeof(pBuffer32x32), "g_AKImage_Cross_32x32");
    if (g_AKImage_Cross_32x32 != NULL) {
        drvfs_write_string(pFile, g_AKImage_Cross_32x32);
        drvfs_write_string(pFile, "\n\n");
        free(g_AKImage_Cross_32x32);
    }




    return 0;
}